#lang racket

(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

;(test 0 (p))

#|
В большинстве языков используется аппликативный порядок вычисления, то есть сначала вычисляются аргументы,
а потом выполняется над ними процедура. В Racket тоже аппликативный порядок. Поэтому, при запуске, все зациклится,
ибо (p) не может быть высчитано.

Нормальный порядок подразумевает под сомой применение всех процедур, а потом уже подсчет.

Соответсвенно, функция выше будет работать при нормальном порядке, но будет зацикливаться при аппликативном.
|#
